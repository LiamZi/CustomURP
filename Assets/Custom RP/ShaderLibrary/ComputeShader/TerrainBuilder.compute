#ifndef __SHADER_LIBRARY_COMPUTE_SHADER_TERRAIN_BUILDER_COMPUTE__
#define __SHADER_LIBRARY_COMPUTE_SHADER_TERRAIN_BUILDER_COMPUTE__

#pragma kernel TraverseQuadTree
#pragma kernel BuildLodMap
#pragma kernel BuildPatches

#pragma multi_compile_local _ _REVERSE_Z
#pragma multi_compile_local _ _ENABLE_FRUSTUM_CULL
#pragma multi_compile_local _ _ENABLE_HIZ_CULL
#pragma multi_compile_local _ _BOUNDS_DEBUG
#pragma multi_compile_local _ _ENABLE_SEAM

#include "ComputeCommon.hlsl"
#include "../TerrainInput.hlsl"

Texture2D<float4> _MinMaxHeightTexture;
Texture2D<float4> _HeightMap;
RWTexture2D<float4> _LodMap;

ConsumeStructuredBuffer<uint2> _ConsumeNodeList;
AppendStructuredBuffer<uint2> _AppendNodeList;
AppendStructuredBuffer<uint3> _AppendFinalNodeList;
StructuredBuffer<uint3> _FinalNodeList;

RWStructuredBuffer<NodeDescriptor> _NodeDescriptors;

uint _PassLod;
float3 _CameraPositionWS;
float3 _WorldSize;
float4 _WorldLodParams[6];
uint _NodeIDOffsetOfLOD[6];
int _BoundsHeightRedundance;
float4 _NodeEvaluationC;

float4 _CameraFrustumPlanes[6];
ConsumeStructuredBuffer<RenderPatch> _PatchConsumeList;
AppendStructuredBuffer<RenderPatch> _CulledPatchList;

#if _BOUNDS_DEBUG
AppendStructuredBuffer<BoundsDebug> _PatchBoundsList;
#endif

float GetNodeSize(uint lod)
{
    return _WorldLodParams[lod].x;
}

float GetPatchExtent(uint lod)
{
    return _WorldLodParams[lod].y;
}

float GetNodeCount(uint lod)
{
    return _WorldLodParams[lod].z;
}

uint GetSectorCountPerNode(uint lod)
{
    return (uint)_WorldLodParams[lod].w;
}

float2 GetNodePositionWSV2(uint2 node, uint lod){
    float nodeMeterSize = GetNodeSize(lod);
    float nodeCount = GetNodeCount(lod);
    float2 nodePositionWS = ((float2)node - (nodeCount-1) * 0.5) * nodeMeterSize;
    return nodePositionWS;
}


float3 GetNodePositionWS(uint2 node, uint lod)
{
    float2 nodePositionWS = GetNodePositionWSV2(node, lod);
    float2 minMaxHeight = _MinMaxHeightTexture.mips[lod + 3][node].xy;
    float y = (minMaxHeight.x + minMaxHeight.y) * 0.5 * _WorldSize.y;
    return float3(nodePositionWS.x, y, nodePositionWS.y);
}

bool EvaluateNode(uint2 node, uint lod)
{
    float3 positionWS = GetNodePositionWS(node, lod);
    float dis = distance(_CameraPositionWS, positionWS);
    float nodeSize = GetNodeSize(lod);
    float f = dis / (nodeSize * _NodeEvaluationC.x);
    if(f < 1)
    {
        return true;
    }

    return false;
}

uint GetNodeId(uint3 nodeLoc)
{
    return _NodeIDOffsetOfLOD[nodeLoc.z] + nodeLoc.y * GetNodeCount(nodeLoc.z) + nodeLoc.x;
}

uint GetNodeId(uint2 nodeLoc, uint mip)
{
    return GetNodeId(uint3(nodeLoc, mip));
}

[numthreads(1, 1, 1)]
void TraverseQuadTree(CSInput input)
{
    uint2 nodeLoc = _ConsumeNodeList.Consume();
    // nodeLoc = uint2(4, 3);
    uint nodeId = GetNodeId(nodeLoc, _PassLod);
    NodeDescriptor desc = _NodeDescriptors[nodeId];
    
    if(_PassLod > 0 && EvaluateNode(nodeLoc, _PassLod))
    {
        uint2 tmp = nodeLoc * 2;
        uint2 tmp1 = nodeLoc * 2 + uint2(1, 0);
        uint2 tmp2 = nodeLoc * 2 + uint2(0, 1);
        uint2 tmp3 = nodeLoc * 2 + uint2(1, 1);
        
        _AppendNodeList.Append(tmp);
        _AppendNodeList.Append(tmp1);
        _AppendNodeList.Append(tmp2);
        _AppendNodeList.Append(tmp3);
        desc.branch = 1;
    }
    else
    {
        uint3 temp = uint3(nodeLoc, _PassLod);
        _AppendFinalNodeList.Append(temp);
        desc.branch = 0;
    }

    _NodeDescriptors[nodeId] = desc;
}

[numthreads(8, 8, 1)]
void BuildLodMap(CSInput input)
{
    uint2 sectorLoc = input.dispatchThreadID.xy;
    
    [unroll]
    for(uint lod = MAX_TERRAIN_LOD; lod >= 0; lod--)
    {
        uint sectorCount = GetSectorCountPerNode(lod);
        uint2 node = sectorLoc / sectorCount;
        uint nodeId = GetNodeId(node, lod);
        NodeDescriptor desc = _NodeDescriptors[nodeId];
        if(desc.branch == 0)
        {
            _LodMap[sectorLoc] = lod * 1.0 / MAX_TERRAIN_LOD;
            return;
        }
    }
    _LodMap[sectorLoc] = 0;
}

RenderPatch CreatePath(uint3 node, uint2 patchOffset)
{
    uint lod = node.z;
    float nodeMeterSize = GetNodeSize(lod);
    float patchMeterSize = nodeMeterSize / PATCH_COUNT_PER_NODE;
    float2 nodePositionWS = GetNodePositionWSV2(node.xy, lod);
    
    uint2 patchLoc = node.xy * PATCH_COUNT_PER_NODE + patchOffset;
    
    float2 minMaxHeight = _MinMaxHeightTexture.mips[lod][patchLoc].rg * _WorldSize.y + float2(-_BoundsHeightRedundance,_BoundsHeightRedundance);
    RenderPatch patch;
    patch.lod = lod;
    patch.position = nodePositionWS + (patchOffset - (PATCH_COUNT_PER_NODE - 1) * 0.5) * patchMeterSize;
    patch.minMaxHeight = minMaxHeight;
    patch.lodTrans = 0;
    return patch;
}

Bounds GetPatchBounds(RenderPatch patch)
{
    float halfSize = GetPatchExtent(patch.lod);
#if ENABLE_SEAM
    halfSize *= 0.9;
#endif
    Bounds bounds;
    float3 boundsMin,boundsMax;
    boundsMin.xz = patch.position - halfSize;
    boundsMax.xz = patch.position + halfSize;
    boundsMin.y = patch.minMaxHeight.x;
    boundsMax.y = patch.minMaxHeight.y;

    bounds.min = boundsMin;
    bounds.max = boundsMax;
    return bounds;
}

bool IsOutSidePlane(float4 plane, float3 pos)
{
    return dot(plane.xyz, pos) + plane.w < 0;
}

bool IsAABBOutSidePlane(float4 plane,float3 boundsMin,float3 boundsMax){
    return IsOutSidePlane(plane,boundsMin) &&
    IsOutSidePlane(plane,boundsMax) &&
    IsOutSidePlane(plane,float3(boundsMin.x,boundsMin.y,boundsMax.z)) &&
    IsOutSidePlane(plane,float3(boundsMin.x,boundsMax.y,boundsMin.z)) &&
    IsOutSidePlane(plane,float3(boundsMin.x,boundsMax.y,boundsMax.z)) &&
    IsOutSidePlane(plane,float3(boundsMax.x,boundsMin.y,boundsMax.z)) &&
    IsOutSidePlane(plane,float3(boundsMax.x,boundsMax.y,boundsMin.z)) &&
    IsOutSidePlane(plane,float3(boundsMax.x,boundsMin.y,boundsMin.z));
}

bool IsBoundsOutSidePlane(float4 plane, Bounds bounds)
{
    return IsAABBOutSidePlane(plane, bounds.min, bounds.max);
}

bool FrustumCull(float4 planes[6],Bounds bounds)
{
    return IsBoundsOutSidePlane(planes[0],bounds) || 
    IsBoundsOutSidePlane(planes[1],bounds) || 
    IsBoundsOutSidePlane(planes[2],bounds) || 
    IsBoundsOutSidePlane(planes[3],bounds) || 
    IsBoundsOutSidePlane(planes[4],bounds) || 
    IsBoundsOutSidePlane(planes[5],bounds);
}

bool HizOcclusionCull(Bounds bounds)
{
    return false;
}


bool Cull(Bounds bounds)
{
#if _ENABLE_FRUSTUM_CULL
    if(FrustumCull(_CameraFrustumPlanes, bounds))
    {
        return true;
    }
#endif

#if _ENABLE_HIZ_CULL
    if(HizOcclusionCull(bounds))
    {
        return true;
    }
#endif
    return false;
}

uint4 GetSectorBounds(uint3 node)
{
    uint sectorCountPerNode = GetSectorCountPerNode(node.z);
    uint2 sectorMin = node.xy * sectorCountPerNode;
    return uint4(sectorMin, sectorMin + sectorCountPerNode - 1);
}

uint GetLod(uint2 sector)
{
    if(sector.x < 0 || sector.y < 0 || sector.x >= SECTOR_COUNT_WORLD || sector.y >= SECTOR_COUNT_WORLD)
    {
        return 0;
    }

    return round(_LodMap[sector].r * MAX_TERRAIN_LOD);
}

void SetLodTrans(inout RenderPatch patch, uint3 node, uint2 patchOffset)
{
    uint lod = node.z;
    uint4 sectorBounds = GetSectorBounds(node);
    int4 lodTrans = int4(0, 0, 0, 0);
    if(patchOffset.x == 0)
    {
        lodTrans.x = GetLod(sectorBounds.xy + int2(-1, 0)) - lod;
    }

    if(patchOffset.y == 0)
    {
        lodTrans.y = GetLod(sectorBounds.xy  + int2(0, -1)) - lod;
    }

    if(patchOffset.x == 7)
    {
        lodTrans.z = GetLod(sectorBounds.zw + int2(1, 0)) -lod;
    }

    if(patchOffset.y == 7)
    {
        lodTrans.w = GetLod(sectorBounds.zw + int2(0, 1)) - lod;
    }

    patch.lodTrans = (uint4)max(0, lodTrans);
}

[numthreads(8, 8, 1)]
void BuildPatches(CSInput input)
{
    uint3 nodeLoc = _FinalNodeList[input.groupID.x];
    uint2 patchOffset = input.groupThreadID.xy;
    
    RenderPatch patch = CreatePath(nodeLoc, patchOffset);

    Bounds bounds = GetPatchBounds(patch);
    if(Cull(bounds))
    {
        return;
    }

    SetLodTrans(patch, nodeLoc, patchOffset);
    _CulledPatchList.Append(patch);

#if _BOUNDS_DEBUG
    BoundsDebug bd;
    bd.bounds = bounds;
    bd.color = float4((bounds.min + _WorldSize * 0.5) / _WorldSize, 1);
    _PatchBoundsList.Append(bd);
#endif
}

#endif